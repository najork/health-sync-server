// This file was generated by Conjure and should not be manually edited.

package api

import (
	"context"
	"net/http"
	"strconv"

	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/codecs"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-contract/errors"
	"github.com/palantir/conjure-go-runtime/v2/conjure-go-server/httpserver"
	"github.com/palantir/pkg/safejson"
	werror "github.com/palantir/witchcraft-go-error"
	"github.com/palantir/witchcraft-go-server/v2/witchcraft/wresource"
	"github.com/palantir/witchcraft-go-server/v2/wrouter"
)

type ApolloService interface {
	// Triggers metrics collection from the given provider.
	Collect(ctx context.Context, providerArg Provider, requestArg ProviderRequest) error
}

// RegisterRoutesApolloService registers handlers for the ApolloService endpoints with a witchcraft wrouter.
// This should typically be called in a witchcraft server's InitFunc.
// impl provides an implementation of each endpoint, which can assume the request parameters have been parsed
// in accordance with the Conjure specification.
func RegisterRoutesApolloService(router wrouter.Router, impl ApolloService) error {
	handler := apolloServiceHandler{impl: impl}
	resource := wresource.New("apolloservice", router)
	if err := resource.Post("Collect", "/api/collect/{provider}", httpserver.NewJSONHandler(handler.HandleCollect, httpserver.StatusCodeMapper, httpserver.ErrHandler)); err != nil {
		return werror.Wrap(err, "failed to add route", werror.SafeParam("routeName", "Collect"))
	}
	return nil
}

type apolloServiceHandler struct {
	impl ApolloService
}

func (a *apolloServiceHandler) HandleCollect(rw http.ResponseWriter, req *http.Request) error {
	pathParams := wrouter.PathParams(req)
	if pathParams == nil {
		return werror.Wrap(errors.NewInternal(), "path params not found on request: ensure this endpoint is registered with wrouter")
	}
	providerStr, ok := pathParams["provider"]
	if !ok {
		return werror.Wrap(errors.NewInvalidArgument(), "path param not present", werror.SafeParam("pathParamName", "provider"))
	}
	var provider Provider
	providerQuote := strconv.Quote(providerStr)
	if err := safejson.Unmarshal([]byte(providerQuote), &provider); err != nil {
		return werror.Wrap(err, "failed to unmarshal argument", werror.SafeParam("argName", "provider"), werror.SafeParam("argType", "Provider"))
	}
	var request ProviderRequest
	if err := codecs.JSON.Decode(req.Body, &request); err != nil {
		return errors.WrapWithInvalidArgument(err)
	}
	return a.impl.Collect(req.Context(), provider, request)
}
